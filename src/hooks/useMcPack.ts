"use client";
import type { IPack, IMinecraftManifest } from "@/types";
import JSZip, { type JSZipObject } from "jszip";
import { useEffect, useState, useCallback } from "react";
import {
  readBinaryFile,
  readTextFile,
  BaseDirectory,
  writeBinaryFile,
  createDir,
  readDir,
} from "@tauri-apps/api/fs";
import { fetch, ResponseType } from "@tauri-apps/api/http";
import {
  BRTX_RP_NAME,
  BRTX_RELEASE_URL,
  BRTX_PACK_NAME,
  RP_DIR,
  BRTX_SVC_NAME,
} from "@/lib/constants";
import { useModStore, createPackStore } from "@/store";

/**
 * Download latest BRTX release
 * @returns Path to downloaded resource pack
 */
async function download() {
  const res = await fetch<ArrayBuffer>(BRTX_RELEASE_URL, {
    method: "GET",
    timeout: 10000,
    responseType: ResponseType.Binary,
  });

  if (!res.ok) {
    throw new Error("Failed to download resource pack");
  }

  const { appLocalDataDir, join } = await import("@tauri-apps/api/path");

  const dir = await appLocalDataDir();
  const dest = await join(dir, BRTX_PACK_NAME);
  await writeBinaryFile(dest, res.data);

  return dest;
}

/**
 * Open and parse the Better RTX .mcpack file
 * @returns List of files found in .mcpack and the manifest.json contents
 */
async function openPack(src: string): Promise<{
  files: JSZipObject[];
  manifest: IMinecraftManifest;
}> {
  const contents = await readBinaryFile(src, {
    dir: BaseDirectory.AppLocalData,
  });

  const zip: JSZip | undefined = await JSZip.loadAsync(contents);

  const files = zip.filter((_relativePath, file) => {
    if (file.dir) {
      return false;
    }

    return (
      file.name.endsWith(".material.bin") || file.name.endsWith("manifest.json")
    );
  });

  const manifest = JSON.parse(
    (await files
      .find((file) => file.name.endsWith("manifest.json"))
      ?.async("text")) ?? "{}",
  );

  return {
    files,
    manifest,
  };
}

async function openDirectory(src: string): Promise<{
  files: string[];
  manifest: IMinecraftManifest;
}> {
  const entries = await readDir(src, {
    dir: BaseDirectory.AppLocalData,
  });

  const fileList = entries.map((entry) => {
    if (entry.children) {
      return entry.children.filter((child) => {
        return (
          child.path.endsWith(".material.bin") ||
          child.path.endsWith("manifest.json")
        );
      });
    }

    return entry;
  });

  const files = fileList.flat().map(({ path }) => path);

  const manifest = JSON.parse(
    (await readTextFile(
      files.find((file) => file.endsWith("manifest.json")) ?? "",
      {
        dir: BaseDirectory.AppLocalData,
      },
    )) ?? "{}",
  );

  return {
    files,
    manifest,
  };
}
/**
 * Extract a user-submitted .mcpack file
 * @param src Path to user file
 * @returns List of extracted files
 */
export function useExtractUpload(src: string) {
  const [isExtracting, setIsExtracting] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [packDirectory, setPackDirectory] = useState<string>("");
  const [uuid, setUuid] = useState<string>("");

  return {
    isExtracting,
    error,
    packDirectory,
    uuid,
    async getData(): Promise<string[] | null> {
      const { join, basename, appLocalDataDir } = await import(
        "@tauri-apps/api/path"
      );
      const { manifest, files } = await openPack(src);

      if (
        !Object.keys(manifest.metadata?.generated_with ?? {}).includes(
          BRTX_SVC_NAME,
        )
      ) {
        throw new Error(
          "Custom packs must be generated by the BetterRTX service",
        );
      }

      setUuid(manifest.header.uuid);

      const packDir = await join(
        await appLocalDataDir(),
        RP_DIR,
        manifest.header.uuid,
        await basename(src, ".mcpack"),
      );

      await createDir(packDir, { recursive: true });

      setPackDirectory(packDir);

      try {
        setIsExtracting(true);
        const res = await Promise.all(
          files.map(async (file) => {
            const data = await file?.async("uint8array");

            if (!data) {
              return null;
            }

            const destDir = await join(packDir, "renderer", "materials");

            await createDir(destDir, { recursive: true });

            await writeBinaryFile(
              await join(destDir, await basename(file.name)),
              data,
            );

            return file;
          }),
        );

        setIsExtracting(false);

        return res.map((file) => file?.name ?? "");
      } catch (e) {
        setError(e as Error);
      } finally {
        setIsExtracting(false);
      }

      return null;
    },
  };
}

/**
 * Fetch and extract materials from a .mcpack
 * @param pack BRTX pack to extract
 * @returns Hook for extracting a BRTX pack
 */
export function useExtractPack(pack: IPack) {
  const { getState, setState } = createPackStore(pack);

  const getData = useCallback(
    async (src: string, extractTo?: string) => {
      const { join, basename, appLocalDataDir } = await import(
        "@tauri-apps/api/path"
      );

      try {
        const { files: fileList } = await openPack(src);

        setState({ files: fileList.map((f) => f.name), isExtracting: false });

        // Pack directory under the installer's app data directory.
        // Needs to be moved to the sideloaded instance's directory
        const packDir =
          extractTo ?? (await join(await appLocalDataDir(), RP_DIR, pack.uuid));

        await createDir(packDir, { recursive: true });

        setState({ isExtracting: true, packDirectory: packDir });
        await Promise.all(
          fileList.map(async (file, idx) => {
            const data = await file.async("uint8array");

            if (!data) {
              return null;
            }

            const destDir = await join(
              packDir,
              pack.name,
              "renderer",
              "materials",
            );

            await createDir(destDir, { recursive: true });

            const dest = await join(destDir, await basename(file.name));

            await writeBinaryFile(dest, data);

            setState({ progress: Math.floor((idx / fileList.length) * 100) });

            return file;
          }),
        );

        setState({ isExtracting: false, progress: 0 });
      } catch (e) {
        setState({ error: e as Error, isExtracting: false, progress: 0 });
      } finally {
        setState({ isExtracting: false });
      }
    },
    [setState, pack.name, pack.uuid],
  );

  useEffect(() => {
    if (!pack.path) {
      return;
    }

    getData(pack.path);
  }, [pack.path, getData]);

  return {
    ...getState(),
    download,
    getData,
  };
}

/**
 * Extract a .mcpack with subpacks
 * @returns Hook for opening a .mcpack with subpacks
 */
export function useSubpacks(file?: string) {
  const [error, setError] = useState<Error | null>(null);
  const { addPack } = useModStore();

  const open = useCallback(async () => {
    const { join, appLocalDataDir } = await import("@tauri-apps/api/path");
    const { files, manifest } = await openPack(file ?? BRTX_PACK_NAME);

    try {
      await Promise.all(
        manifest.subpacks?.map(
          async (subpack: Record<string, string | number>) => {
            const pack: IPack = {
              title: subpack.description as string,
              name: subpack.name as string,
              uuid: subpack.uuid as string,
              path: await join(
                await appLocalDataDir(),
                RP_DIR,
                subpack.uuid as string,
              ),
            };
            addPack(pack);
          },
        ) ?? [],
      );
    } catch (e) {
      setError(e as Error);
    }
    return { files, manifest };
  }, [addPack, file]);

  return {
    error,
    open,
  };
}
